package com.zoomigo.whatsapp.batchmailsender.integration;

import com.zoomigo.whatsapp.batchmailsender.config.BatchProperties;
import com.zoomigo.whatsapp.batchmailsender.job.JobEngine;
import jakarta.mail.Session;
import jakarta.mail.internet.MimeMessage;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;

@SpringBootTest
public class BookingJobIntegrationTest {

    @Autowired
    JdbcTemplate jdbc;

    @Autowired
    BatchProperties batchProperties;

    @Autowired
    JobEngine jobEngine;

    @MockBean
    JavaMailSender mailSender; // prevent real SMTP activity

    @BeforeEach
    void setupMailSender() {
        // Return a non-null MimeMessage so MimeMessageHelper can initialize multipart content
        MimeMessage mimeMessage = new MimeMessage(Session.getInstance(new Properties()));
        when(mailSender.createMimeMessage()).thenReturn(mimeMessage);
        // Ensure test schema matches JPA mappings for BookingEntity and audit_email
        jdbc.execute("CREATE TABLE IF NOT EXISTS booking (\n"
                + "  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n"
                + "  wa_id VARCHAR(100),\n"
                + "  name VARCHAR(255),\n"
                + "  bike VARCHAR(255),\n"
                + "  duration INT,\n"
                + "  price INT,\n"
                + "  deposit INT,\n"
                + "  status VARCHAR(50),\n"
                + "  start_date DATE,\n"
                + "  end_date DATE,\n"
                + "  pickup_type VARCHAR(50),\n"
                + "  delivery_address TEXT,\n"
                + "  promo_code VARCHAR(100),\n"
                + "  promo_discount_amount INT,\n"
                + "  promo_applied BOOLEAN DEFAULT FALSE,\n"
                + "  currency_unit VARCHAR(10),\n"
                + "  applied_exchange_rate NUMERIC,\n"
                + "  created_at TIMESTAMP,\n"
                + "  cancelled_at TIMESTAMP,\n"
                + "  batch_sent_at TIMESTAMP,\n"
                + "  batch_attempts INT\n"
                + ")");
        // Audit table
        jdbc.execute("CREATE TABLE IF NOT EXISTS audit_email (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, job_name VARCHAR(200) NOT NULL, reference_id VARCHAR(100), payload TEXT, subject TEXT, message_id VARCHAR(200), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)");
    }

    @Test
    void jobProcessesBookingAndCreatesAudit() {
        // Insert a booking with batch_sent_at = null
        jdbc.update("INSERT INTO booking (wa_id, name, bike, duration, price, deposit, status, start_date, end_date, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)",
                "+999000000", "Integration Test", "TestBike", 2, 100, 10, "CONFIRMED", LocalDate.now().plusDays(1), LocalDate.now().plusDays(3));

        List<Map<String,Object>> before = jdbc.queryForList("SELECT id, batch_sent_at FROM booking WHERE wa_id = ?", "+999000000");
        assertThat(before).hasSize(1);
        assertThat(before.get(0).get("batch_sent_at")).isNull();

        // find job config
        BatchProperties.JobConfig cfg = batchProperties.getJobs().stream().filter(j -> "booking-reminder".equals(j.getName())).findFirst().orElseThrow();

        // ensure the job is not in dry-run mode for this test, then run it
        cfg.setDryRun(false);
        // run job synchronously
        jobEngine.runJob(cfg);

        // verify booking updated
        List<Map<String,Object>> after = jdbc.queryForList("SELECT id, batch_sent_at FROM booking WHERE wa_id = ?", "+999000000");
        assertThat(after).hasSize(1);
        assertThat(after.get(0).get("batch_sent_at")).isNotNull();

        // verify audit entry created (check subject and reference_id because some DB/JDBC combos may return null column labels)
        String refId = after.get(0).get("id").toString();
        List<Map<String,Object>> audits = jdbc.queryForList("SELECT reference_id, subject FROM audit_email WHERE reference_id = ?", refId);
        assertThat(audits).isNotEmpty();
        Map<String,Object> firstAudit = audits.get(0);
        Object subjectObj = firstAudit.get("subject");
        if (subjectObj == null) subjectObj = firstAudit.get("SUBJECT");
        assertThat(subjectObj).as("audit subject should not be null").isNotNull();
        assertThat(subjectObj.toString()).isEqualTo("New Booking Received");
        Object referenceObj = firstAudit.get("reference_id");
        if (referenceObj == null) referenceObj = firstAudit.get("REFERENCE_ID");
        assertThat(referenceObj).isNotNull();
        assertThat(referenceObj.toString()).isEqualTo(refId);
    }

    @DynamicPropertySource
    static void registerDynProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", () -> "jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL");
        registry.add("spring.datasource.driverClassName", () -> "org.h2.Driver");
        registry.add("spring.datasource.username", () -> "sa");
        registry.add("spring.datasource.password", () -> "");
        registry.add("spring.flyway.enabled", () -> "false");
        registry.add("spring.jpa.database-platform", () -> "org.hibernate.dialect.H2Dialect");
        registry.add("spring.jpa.hibernate.ddl-auto", () -> "none");
        // Ensure the job is not in dry-run mode for the integration test so it marks bookings processed
        registry.add("JOB_BOOKING_DRY_RUN", () -> "false");
    }
}
